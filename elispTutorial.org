#+TITLE: Elisp tutorial


* List processing

** Lisp lists

Lisp can be written as '(rose violet daisy buttercup)

*** Atoms
Indivisible parts. Examples: numbers, symbols(words), text between quotation.
 - Sexp (symbolic expression): printed representation of both atoms and lists

*** Whitespace in lists
The amount in a list does not matter. Only used to improve readability.

** The lisp interpreter
Looks for a quote before the list, if there is one, returns the list, otherwise
looks for a function of the first element.

*** Complications
 - Can evaluate a symbol that is not quoted or does not have parenthesis
 - Special forms (functions).
 - Macros: translates a Lisp expression into another to be evaluated in place
   of it
 - Inner list always evaluated first. Otherwise, from left to right.

** Run a program
A list is a program ready to run.

A quote
 - When it precedes a list it tells to do nothing with it, other than take it
   as it is written. If there is no quote, the first item is taken as a
   function.

** Generate an error message
Generated by emacs debugger. To quit, use q

(void-function this)

One line message in the echo area:
Symbol's function definition is void: this

** Evaluation
When the interpreter works on an expression.
The interpreter: returns a value and side effects (copy a file, move the
cursor) or else produce an error.

*** Inner lists

** Variables
A symbol can have a value attached to it just as it can have a function
definition attached to it.
A symbol that has a value.

When there is a variable, we don't place parentheses around it,as we don't
intend to use it as a function.

** Arguments
Information given or "passed" to a function.
In Lisp, are the atoms or lists that follow the function.

*** Useful tips
 - concat: links two or more strings to produce a new one. Arguments are
   strings. (concat "abc" "def")
 - substring: returns a part of a string. Uses strings and numbers as
   arguments. First the string, second and third beginning and end of
   substring. (substring "The quick brown fox jumped." 16 19)
 - An argument can be a variable of a value of an list evaluation.
 (concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
 - message: printed in the echo area.

#+BEGIN_SRC emacs-lisp
(message "The name of this buffer is %s." (buffer-name))
#+END_SRC  

#+BEGIN_SRC emacs-lisp
(message "He saw %d %s"
         (- fill-column 32)
         (concat "red "
                 (substring
                  "The quick brown foxes jumped." 16 21)
                 " leaping."))
#+END_SRC

#+RESULTS:
: He saw 47 red foxes leaping.
** Setting the value of a variable
Ways by which a variable can be given a value. Bind a variable to a value

*** Set

(set 'flowers '(rose violet daisy buttercup))
Needs to quote both arguments to set

*** setq
set and quoted first argument. Allows you to set different variables to
different values.

#+BEGIN_SRC emacs-lisp
(setq carnivores '(lion tiger leopard))
#+END_SRC

Multiple assignments

#+BEGIN_SRC emacs-lisp
(setq trees '(pine fir oak maple)
      herbivores '(gazelle antelope zebra))
#+END_SRC

Symbols are set to point to the list.

*** Counting
Example of using ~setq~ in a counter

#+BEGIN_SRC emacs-lisp
(setq counter 0)  ; Initializer
(setq counter (+ counter 1))  ; Incrementer
counter  ; Counter
#+END_SRC

#+RESULTS:
: 1

** Exercises

*** Exercise 1
Generate an error message by evaluating an appropriate symbol that is not
within parentheses.

setq

*** Exercise 2
Generate an error message by evaluating an appropriate symbol that is between
parentheses.

(foo)

*** Exercise 3
Create a counter that increments by two rather than one.

#+BEGIN_SRC emacs-lisp
(setq counter 0)
(setq counter (+ counter 2))
counter
#+END_SRC

#+RESULTS:
: 2

*** Exercise 4
Write an expression that prints a message in the echo area when evaluated.
#+BEGIN_SRC emacs-lisp :var counter=1
(message "I have run this line %d times so far" (setq counter (+ counter 1)))
#+END_SRC

#+RESULTS:
: I have run this line 2 times so far

* Practicing evaluation
Evaluate different buffer-related expressions.

** How to
  - Pressing any key in emacs evaluates a function. Called *Interactive
    functions* or *commands*
  - "C-x C-e"
  - Others...

** Buffer names 
 - (buffer-name)
 - (buffer-file-name)

Some important definitions:
 - File :: information recorded permanently in a computer
 - Buffer :: information inside Emacs that wil vanish at the end of the
      session.

~C-u C-x C-e~ allows to insert the value returned in the buffer.

** Getting buffers
To get the buffer itself, the function ~current-buffer~ is used.
If the function is evaluated, it shows the name of the buffer only.
 - (current-buffer)

 - (other-buffer) Returns the most recently selected buffer other than the one
   you are currently in

** Switching buffers
 - (switch-to-buffer (other-buffer)): switches the buffer and shows it in the
   window

Emacs implements it as an interactive function with ~C-x b~
The function ~set-buffer~ changes focus to buffer only.

** Buffer size and the location of point

 - (buffer-size) : count of number of chars in a buffer
 - (point): number, where the cursor is located form the beginning of the
   buffer
 - (point-min)
 - (point-max)

** Exercise
 - (buffer-name)  "elispTutorial.org"
 - (buffer-file-name)
   "/home/carlosperez/Documents/learning/emacs/elisp/elispTutorial.org" 
 - (buffer-size) 10670
 - (point) 5387

* How to write function definitions

** The ~defun~ macro
A function definition is code attached to it that tells the computer what to do
when the function is called. It starts with the symbol ~defun~

Parts of a function:
 - Name of the symbol to which is attached
 - List of args. If not, the empty list ()
 - Documentation
 - Expression to make it interactive, to use it after ~M-x~
 - Code or body

     (defun FUNCTION-NAME (ARGUMENTS…)
       "OPTIONAL-DOCUMENTATION…"
       (interactive ARGUMENT-PASSING-INFO)     ; optional
       BODY…)

An example:
     (defun multiply-by-seven (number)
       "Multiply NUMBER by seven."
       (* 7 number))

** Install a function definition
Evaluate a defun with ~C-x C-e~, so it is installed in Emacs

*** Change a function definition
Just rewrite and re evaluate it

** Make a function interactive
You make it by placing a list that begins with the special form 'interactive'
inmediately after the documentation.

When a function is called interactively, the value returned is not
automatically displayed.

*** Example

     (defun multiply-by-seven (number)       ; Interactive version.
       "Multiply NUMBER by seven."
       (interactive "p")
       (message "The result is %d" (* 7 number)))

A prefix argument is passed to an interactive function by typing the <META> key
followed by a number, for example, ‘M-3 M-e’, or by typing ‘C-u’ and then a
number, for example, ‘C-u 3 M-e’ (if you type ‘C-u’ without a number, it
defaults to 4).

** Different options for interactive
(interactive "p")

 - p: Interpret your typing C-u as a command to pass the number to the function
   as its argument.

     (interactive "p\ncZap to char: ")

** Install code permanently
Different options
 - Put the code in your .emacs init file
 - Use the ~load~ function
 - Put it in ~site-init.el~ . Makes it available for anyone using the machine

** Let
Used to attach or bind a symbol to a value in such a way that the Lisp
interpreter will not confuse the variable with a variable of the same name that
is not part of the function.

Used to name local variables. It is like a temporary and local ~setq~

After ‘let’ has created and bound the variables, it executes the code in the
body of the ‘let’, and returns the value of the last expression in the body, as
the value of the whole ‘let’ expression.

*** Parts
A ~let~ expression is a list of 3 parts.
 1) Symbol ~let~
 2) varlist: each element is a symbol by itself or a two-element list
 3) body: one or more lists


(let VARLIST BODY...)

(let ((VARIABLE VALUE)
     (VARIABLE VALUE)
     …)
 BODY…)

*** Sample ~let~ expression

     (let ((zebra 'stripes)
           (tiger 'fierce))
       (message "One kind of animal has %s and another is %s."
                zebra tiger))

If you do not bind the variables in a ‘let’ statement to specific initial
values, they will automatically be bound to an initial value of ‘nil

** The ~if~ special form
Conditional, instructs the computer to make decisions.

     (if TRUE-OR-FALSE-TEST
         ACTION-TO-CARRY-OUT-IF-TEST-IS-TRUE)

An example:
#+BEGIN_SRC emacs-lisp
(if (> 5 4)                             ; if-part
    (message "5 is greater than 4!"))   ; then-part
#+END_SRC

The function > tests whether its first argument is greater than its second
     argument and returns true if it is.

The value to test is usually not known beforehand

#+BEGIN_SRC emacs-lisp
(defun type-of-animal (characteristic)
  "Print message in echo area depending on CHARACTERISTIC.
     If the CHARACTERISTIC is the symbol `fierce',
     then warn of a tiger."
  (if (equal characteristic 'fierce)
      (message "It's a tiger!")))

#+END_SRC

In Lisp, ‘equal’ is a function that determines whether its first argument is
equal to its second argument.

** ~If-then-else~ expressions
An ~if~ expression might have an optional third argument, the ~else-part~, when
the true-or-false-test returns false.

The word ~else~ is not written in the codes. It comes after the then part.

     (if TRUE-OR-FALSE-TEST
         ACTION-TO-CARRY-OUT-IF-THE-TEST-RETURNS-TRUE
       ACTION-TO-CARRY-OUT-IF-THE-TEST-RETURNS-FALSE)

#+BEGIN_SRC emacs-lisp
(if (> 4 5)                               ; if-part
    (message "4 falsely greater than 5!") ; then-part
  (message "4 is not greater than 5!"))   ; else-part
#+END_SRC

** Truth and falsehood in Elisp
The expression that tests for truth is interpreted as "true" if the result of
evaluating is a value that is not "nil". Could be a number for example.

*** Nil explained
Two meanings:
 - Empty list ()
 - False

** ~save-excursion~
Saves the location of point and mark, executes the body of the function, and
then restores point and mark to their previous positions.

*** Point and mark
 - Point: current location of the cursor. When it appears on top of a
   character, it is inmediately before (point)
 - Mark: Another position, set by C-<SPC> (set-mark-command). You can use the
   command C-x C-x (exchange-point-and-mark) to cause the cursor to jump to the
   mark and set the mark to be the previous position of point. You can jump to
   a previous mark with C-u C-<SPC>. They are saved in the mark ring.
 - Region: the part of the buffer between point and mark.

*** Template for using it

     (save-excursion
       BODY…)

Often occurs inside a ~let~ expression

     (let VARLIST
       (save-excursion
         BODY…))

#+BEGIN_SRC emacs-lisp
(message "We are %d characters into this buffer."
         (- (point)
            (save-excursion
              (goto-char (point-min)) (point))))
#+END_SRC

#+RESULTS:
: We are 12613 characters into this buffer.

** Exercises

*** Exercise 1
Write a non-interactive function that doubles the value of its argument, a
number.  Make that function interactive.

#+BEGIN_SRC emacs-lisp

(defun double (number)
  "Doubles the value of the argument"
  (* 2 number)
  )

(defun double-interactive (number)
  "Doubles the value of the argument"
  (interactive "p")
  (message "The result is %d" (* 2 number))
  )

(double 3)
#+END_SRC

#+RESULTS:
: 6

*** Exercise 2
Write a function that tests whether the current value of ~fill-column~ is
greater than the argument passed to the function, and if so, prints an
appropriate message.

#+BEGIN_SRC emacs-lisp
(defun carlos-greater-than-fill-column-p (value)
  "Test whether VALUE is greater than 'fill-column'."
  (if (> value fill-column)
      (message "%d is greater than %s" value 'fill-column)
    (message "%s is greater than %d" 'fill-column value)
    )
  )

(carlos-greater-than-fill-column-p 87)
#+END_SRC

#+RESULTS:
: 87 is greater than fill-column




* Buffer-related functions
Explore in detail several functions related to buffers.

** Find more info
 - ~C-h f~ and the name of the function
 - ~C-h v~ and the name of the variable
 - ~describe-function~ tells the location of the function definition
 - ~find-tag~
 - TAGS table

** beginning-of-buffer
Generally bound to M-<

Shortened version:
 - Expression to make it interactive
 - Leave a mark at the original position
 - Move the cursor to the beginning of the buffer.

#+BEGIN_SRC emacs-lisp
(defun simplified-beginning-of-buffer ()
  "Move point to the beginning of the buffer;
     leave mark at previous position."
  (interactive)
  (push-mark)
  (goto-char (point-min)))
#+END_SRC

Body:
 - ~push-mark~: sets a mark at the current position of the cursor.
 - ~goto-char~: jumps the cursor to a point.

** mark-whole-buffer
Bound to C-x h
Marks a whole buffer as a region by putting point at the beginning and mark at
the end of the buffer.

#+BEGIN_SRC emacs-lisp
(defun mark-whole-buffer ()
  "Put point at beginning and mark at end of buffer.
     You probably should not use this function in Lisp programs;
     it is usually a mistake for a Lisp function to use any subroutine
     that uses or sets the mark."
  (interactive)
  (push-mark (point))
  (push-mark (point-max) nil t)
  (goto-char (point-min)))

#+END_SRC

** append-to-buffer
Copy the region from the current buffer to a specified buffer.

*** Overview
Uses the ~insert-buffer-substring~ function to copy the region.
Most of the code is about setting up the conditions for it to work. The code
must specify:
 - the buffer to which the text will go
 - the window it comes from and goes to
 - the region that will be copied

#+BEGIN_SRC emacs-lisp
(defun append-to-buffer (buffer start end)
  "Append to specified buffer the text of the region.
     It is inserted into that buffer before its point.

     When calling from a program, give three arguments:
     BUFFER (or buffer name), START and END.
     START and END specify the portion of the current buffer to be copied."
  
  (interactive
   (list (read-buffer "Append to buffer: " (other-buffer
                                            (current-buffer) t))
         (region-beginning) (region-end))) 
  
  (let ((oldbuf (current-buffer)))
    (save-excursion
      (let* ((append-to (get-buffer-create buffer))
             (windows (get-buffer-window-list append-to t t))
             point)
        (set-buffer append-to)
        (setq point (point))
        (barf-if-buffer-read-only)
        (insert-buffer-substring oldbuf start end)
        (dolist (window windows)
          (when (= (window-point window) point)
            (set-window-point window (point))))))))

#+END_SRC

*** Interactive expression
It starts a list for interactive parts

 - Read the name of a buffer and return it as a string ~read-buffer~
   - Prompt
   - Value to provide if nothing is specified (other-buffer (current-buffer) t)
 - beginning of text to be appended
 - end of text to be appended

*** Body

(defun append-to-buffer (buffer start end) "DOCUMENTATION…"  (interactive
…)  (let ((VARIABLE VALUE)) BODY…)

The ‘let’ expression has three elements:

  1. The symbol ‘let’;
  2. A varlist containing, in this case, a single two-element list, ‘(VARIABLE
     VALUE)’;
  3. The body of the ‘let’ expression.
